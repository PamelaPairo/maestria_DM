---
title: "Clase Práctica nº1"
author: "Adaptación del material hecho por Juan Barriola y Sofía Perini"
lang: es
description: |
  Repaso R y Inferencia Estadística
format:
  html:
    theme: flatly
    code-fold: show
    code-tools: true
    toc: true
    toc-location: left
---

<style type="text/css">
div.main-container {
  max-width: 1600px;
  margin-left: auto;
  margin-right: auto;
}
</style>

![https://cran.r-project.org/](https://raw.githubusercontent.com/eea-uba/EEA-2024/refs/heads/main/clase%201/Rlogo.png){width=100}

# Repaso R

### ¿Qué es R?

- Lenguaje para el procesamiento y análisis estadístico de datos
- Software Libre
- Sintaxis Básica: R base 
- Sintaxis incremental[^1]: El lenguaje se va ampliando por aportes de Universidades, investigadores/as, usuarios/as y empresas privadas, organizados en librerías (o paquetes)
- Comunidad web muy grande para realizar preguntas y despejar dudas. Por ejemplo, en el caso de Buenos Aires contamos con [RenBaires](https://www.meetup.com/es-ES/renbaires/) y [R-Ladies Buenos Aires](https://www.meetup.com/es-ES/rladies-buenos-aires/)

[^1]: Más allá de los comandos elementales, comandos más sofisticados tienen muchas versiones, y algunas quedan en desuso en el tiempo.

![Fuente: https://gist.github.com/daroczig/3cf06d6db4be2bbe3368](https://raw.githubusercontent.com/eea-uba/EEA-2024/refs/heads/main/clase%201/number-of-submitted-packages-to-CRAN.png){width=1000}


![https://www.rstudio.com/](https://raw.githubusercontent.com/eea-uba/EEA-2024/refs/heads/main/clase%201/RStudiologo.png){width=200}

Uno de los _entornos_ más cómodos para utilizar el _lenguaje_ __R__ es el _programa_ __R studio__.

- Rstudio es una empresa que produce productos asociados al lenguaje R, como el programa sobre el que corremos los comandos, y extensiones del lenguaje (librerías).
 
- El programa es _gratuito_ y se puede bajar de la 
[página oficial](https://www.rstudio.com/) 


![Pantalla Rstudio](https://raw.githubusercontent.com/eea-uba/EEA-2024/refs/heads/main/clase%201/Pantalla%20Rstudio.png){width=1000}

### Lógica sintáctica

#### Definición de objetos

Los __Objetos/Elementos__ constituyen la categoría esencial del R. De hecho, todo en R es un objeto, y se almacena con un nombre específico que **no debe poseer espacios**. Un número, un vector, una función, la progresión de letras del abecedario, una base de datos, un gráfico, constituyen para R objetos de distinto tipo. Los objetos que vamos creando a medida que trabajamos pueden visualizarse en el panel derecho superior de la pantalla (el _Environment_). 

El operador __```<-```__ (__Alt + Guión__) sirve para definir un objeto.  __A la izquierda__ del __```<-```__ debe ubicarse el nombre que tomará el elemento a crear. __Del lado derecho__ debe ir la definición del mismo.


```{r}
A <- 1
```

Por ejemplo, podemos crear el elemento __A__, cuyo valor será 1. Para esto, debemos _correr_ el código presionando __Ctrl + Enter__, con el cursor ubicado en cualquier parte de la línea. Al definir un elemento, el mismo queda guardado en el ambiente del programa, y podrá ser utilizado posteriormente para observar su contenido o para realizar una operación con el mismo.

```{r}
A 
A+6
```

Al correr una linea con el nombre del objeto, la consola del programa nos muestra su contenido. Entre corchetes observamos el número de orden del elemento en cuestión. Si corremos una operación, la consola nos muestra el resultado de la misma.

El operador __```=```__ es __equivalente__ a __```<-```__.   

```{r}
B = 2
B
```

__```<-```__ es un operador __unidireccional__, es decir que:     
```A <- B``` implica que __A__ va tomar como valor el contenido del objeto __B__, y no al revés.

```{r}
A <- B
A      # Ahora A toma el valor de B, y B continúa conservando el mismo valor
B
```


### R base

Con _R base_ nos referimos a los comandos básicos que vienen incorporados en el R, sin necesidad de cargar librerías. 

#### Operadores lógicos: 

- $>$ (mayor a-)
- $>=$ (mayor o igual a-)
- $<$ (menor a-)
- $<=$ (menor o igual a-)
- $==$ (igual a-)
- $!=$ (distinto a-)

```{r}
# Redefinimos los valores A y B
A <- 10
B <- 20

# Realizamos comparaciones lógicas
A >  B
A >= B
A <  B
A <= B
A == B
A != B

C <- A != B
C
```

Como muestra el último ejemplo, el resultado de una operación lógica puede almacenarse como el valor de un objeto.

#### Operadores aritméticos:

```{r}
#suma
A <- 5+6
A
#Resta
B <- 6-8
B
#cociente
C <- 6/2.5
C
#multiplicacion
D <- 6*2.5
D
```

#### Funciones:

Las funciones son series de procedimientos estandarizados, que toman como input determinados argumentos a fijar por el usuario, y devuelven un resultado acorde a la aplicación de dichos procedimientos. Su lógica de funcionamiento es:   
```funcion(argumento1 = arg1, argumento2 = arg2)```      

A lo largo del curso iremos viendo numerosas funciones, según lo requieran los distintos ejercicios. Sin embargo, veamos ahora algunos ejemplos para comprender su funcionamiento:    

- paste() : concatena una serie de caracteres, pudiendo indicarse cómo separar a cada uno de ellos        
- paste0(): concatena una serie de caracteres sin separar
- sum(): suma de todos los elementos de un vector   
- mean() promedio aritmético de todos los elementos de un vector   

```{r}
paste("Pega", "estas", 4, "palabras", sep = " ")

# Puedo concatenar caracteres almacenados en objetos
paste(A, B, C, sep = "**")

# Paste0 pega los caracteres sin separador
paste0(A, B, C)

1:5

sum(1:5)

mean(1:5, na.rm = TRUE)
```


#### Caracteres especiales:

- R es sensible a mayúsculas y minúsculas, tanto para los nombres de las variables, como para las funciones y parámetros.
- Los __espacios en blanco__ y los __carriage return__ (_enter_) no son considerados por el lenguaje. Los podemos aprovechar para emprolijar el código y que la lectura sea más simple[^2].

[^2]: veremos que existen ciertas excepciones con algunos paquetes más adelante. 

- El __numeral__ ```#``` se utiliza para hacer comentarios. Todo lo que se escribe después del # no es interpretado por R. Se debe utilizar un # por cada línea de código que se desea anular

- Los __corchetes__ ```[]``` se utilizan para acceder a un objeto:
    - en un vector[n° orden]
    - en una tabla[fila, columna]
    - en una lista[n° elemento]   
    
- el signo __$__ también es un método de acceso. Particularmente, en los dataframes, nos permitira acceder a una determinada columna de una tabla

- Los __paréntesis__```()``` se utilizan en las funciones para definir los parámetros.

- Las __comas__ ```, ```  se utilizan para separar los parametros al interior de una función. 

### Objetos    

Existe una gran cantidad de objetos distintos en R, en lo que respecta al curso trabajaremos principalmente con 3 de ellos:

1. Valores
2. Vectores
3. Data Frames
4. Listas

#### 1. Valores:

Los valores y vectores pueden ser a su vez de distintas _clases_:   

*Numeric*

```{r}
A <-  1
class(A)
```

_Character_

```{r}
A <-  paste('Soy', 'una', 'concatenación', 'de', 'caracteres', sep = " ")
A
class(A)
```

_Factor_

```{r}
A <- factor("Soy un factor, con niveles fijos")
class(A)
```

La diferencia entre un _character_ y un _factor_ es que el último tiene solo algunos valores permitidos (levels), con un orden interno predefinido (el cual, por ejemplo, se respetará a la hora de realizar un gráfico).  


#### 2. Vectores:

Para crear un __vector__ utilizamos el comando ```c()```, de combinar.

```{r}
C <- c(1, 3, 4)
C
```

Podemos sumarle 2 a cada elemento del __vector__ anterior

```{r}
C <- C + 2
C
```

O sumarle 1 al primer elemento, 2 al segundo, y 3 al tercer elemento del __vector__ anterior

```{r}
D <- C + 1:3 # esto es equivalente a hacer 3+1, 5+2, 6+9 
D
```

```1:3``` significa que queremos todos los números enteros desde 1 hasta 3. 

Podemos crear un __vector__ que contenga las palabras: "Carlos", "Federico", "Pedro"

```{r}
E <- c("Carlos", "Federico", "Pedro")
E
```

Para acceder a algún elemento del vector, podemos buscarlo por su número de orden, entre ```[ ]```

```{r}
E[2]
```

Si nos interesa almacenar dicho valor, al buscarlo lo asignamos a un nuevo objeto, dándole el nombre que deseemos

```{r}
elemento2 <- E[2]
```

```{r}
elemento2
```

R implicitamente coerciona la longitud de los [vectores](https://es.r4ds.hadley.nz/vectores.html). Esto se denomina __reciclado de vectores__ (*vector recicling*), debido a que el vector de menor longitud se repite, o recicla, hasta igualar la longitud del vector más largo.

```{r}
# sumamos dos vectores de distinta longitud
G <- 1:10 + 1:2 
G 
```

Vemos que para efectuar la suma el vector menor (1 y 2) se repite para alcanzar la longitud del vector más largo (1 a 10) y le adiciona 1 y 2 a medida que recorre el vector más largo.  

Para __borrar__ un objeto del ambiente de trabajo, utilizamos el comando _```rm()```_

```{r error=TRUE}
rm(elemento2)
elemento2
```

También podemos cambiar el texto del segundo elemento de E, por el texto "Pablo"

```{r}
E[2] <- "Pablo"
E
```

#### 3. Data Frames:

Un Data Frame es una tabla de datos, donde cada columna representa una variable, y cada fila una observación.

Este objeto suele ser central en el proceso de trabajo, y suele ser la forma en que se cargan datos externos para trabajar en el ambiente de R, y en que se exportan los resultados de nuestros trabajo.  

También se puede crear como la combinación de N vectores de igual tamaño. Por ejemplo, tomamos algunos valores del [Indice de salarios](https://www.indec.gob.ar/indec/web/Nivel4-Tema-4-31-61) del INDEC.

```{r}
INDICE  <- c( 286.4,	262.1,	248.5,
              285.7,	263.5,	250.2,
              285.1,	264.9,	249.0 )


FECHA  <-  c("Mar-20", "Mar-20", "Mar-20",
             "Abr-20", "Abr-20", "Abr-20",
             "May-20", "May-20", "May-20")

GRUPO  <-  c("Privado_Registrado","Público","Privado_No_Registrado",
             "Privado_Registrado","Público","Privado_No_Registrado",
             "Privado_Registrado","Público","Privado_No_Registrado")

Datos <- data.frame(INDICE, FECHA, GRUPO)
Datos
```

Tal como en un __vector__ se ubica a los elementos mediante ```[ ]```, en un __dataframe__ se obtienen sus elementos de la forma __```[fila, columna]```__.

Otra opción es especificar la columna, mediante el operador __```$```__, y luego seleccionar dentro de esa columna el registro deseado mediante el número de orden.

```{r}
Datos$FECHA
Datos[3,2]
Datos$FECHA[3]
```

¿que pasa si hacemos ```Datos$FECHA[3,2]``` ?

```{r error=TRUE}
Datos$FECHA[3,2]
```

Nótese que el último comando tiene un número incorrecto de dimensiones, porque estamos refiriendonos 2 veces a la columna FECHA.    

Acorde a lo visto anteriormente, el acceso a los __dataframes__ mediante  ```[ ]``` puede utilizarse para realizar filtros sobre la base, especificando una condición para las filas. Por ejemplo, puedo utilizar los  ```[ ]``` para conservar del __dataframe__ ```Datos ```  unicamente los registros con fecha de Diciembre 2016:

```{r error=TRUE}
Datos[Datos$FECHA == "May-20",]
```

La lógica del paso anterior sería: Accedo al dataframe ```Datos```, pidiendo únicamente conservar las filas (por eso la condición se ubica a la _izquierda_ de la  ```, ```) que cumplan el requisito de pertenecer a la categoría __"May-20"__ de la variable __FECHA__.    

Aún más, podría aplicar el filtro y al mismo tiempo identificar una variable de interés para luego realizar un cálculo sobre aquella. Por ejemplo, podría calcular la media de los indices en el mes de Diciembre. 

```{r error=TRUE}
# Por separado
Indices_May <- Datos$INDICE[Datos$FECHA == "May-20"]
Indices_May
```

```{r error=TRUE}
mean(Indices_May)
```

```{r error=TRUE}
# Todo junto
mean(Datos$INDICE[Datos$FECHA == "May-20"])
```

La lógica de esta sintaxis sería: "Me quedo con la variable __INDICE__, cuando la variable FECHA sea igual a __"May-20"__, luego calculo la media de dichos valores".

#### 4. Listas

Contienen una concatenación de objetos de cualquier tipo. Así como un vector contiene valores, un dataframe contiene vectores, una lista puede contener dataframes, pero también vectores, o valores, y _todo ello a la vez_.

```{r}
superlista <- list(A,B,C,D,E,FECHA, DF = Datos, INDICE, GRUPO)
superlista
```

Para acceder un elemento de una lista, podemos utilizar el operador __```$```__, que se puede usar a su vez de forma iterativa. 

```{r}
superlista$DF$FECHA[2]
```

### Ambientes de trabajo

Hay algunas cosas que tenemos que tener en cuenta respecto del orden del ambiente en el que trabajamos:

- **Working Directory**: Es el directorio de trabajo. Pueden ver el suyo con `getwd()`, es *hacia donde apunta el código*, por ejemplo, si quieren leer un archivo, la ruta del archivo tiene que estar explicitada como el recorrido desde el Working Directory.
- **Environment**: Esto engloba tanto la información que tenemos cargada en *Data* y *Values*, como las librerías que tenemos cargadas mientras trabajamos. 

Es importante que mantengamos bien delimitadas estas cosas entre diferentes trabajos, sino:

1. El directorio queda referido a un lugar específico en nuestra computadora. 
  - Si se lo compartimos a otro **se rompe**
  - Si cambiamos de computadora **se rompe**
  - Si lo cambiamos de lugar **se rompe**
  - Si primero abrimos otro script **se rompe**
2. Tenemos mezclados resultados de diferentes trabajos:
  - Nunca sabemos si esa variable/tabla/lista se creo en ese script y no otro
  - Perdemos espacio de la memoria
  - No estamos seguros de que el script cargue todas las librerías que necesita

#### Proyectos

Rstudio tiene una herramienta muy útil de trabajo que son los **proyectos**. Estos permiten mantener un ambiente de trabajo delimitado por cada uno de nuestros trabajos. Es decir:

- El directorio de trabajo se refiere a donde esta ubicado el archivo .Rproj
- El Environment es específico de nuestro proyecto.

Un proyecto no es un sólo script, sino toda una carpeta de trabajo. 

![logo Rpoject](https://raw.githubusercontent.com/eea-uba/EEA-2024/refs/heads/main/clase%201/Rproject.png){width=100}

Para crearlo, vamos al logo de nuevo projecto (Arriba a la derecha de la panatalla), y elegimos la carpeta de trabajo. 

#### Tipos de archivos de R

- __Script__: Es un archivo de texto plano, donde podemos poner el código que utilizamos para preservarlo
- __Rnotebook__: También sirve para guardar el código, pero a diferencia de los scripts, se puede compilar, e intercalar código con resultados (este archivo es un rnotebook)
- __Rproject__: Es un archivo que define la metadata del proyecto
- __RDS y Rdata__: Dos formatos de archivos propios de R para guardar datos. 

## Algunos tips

Para agregar un bloque de código `Ctrl+ Alt+ I`

Para agregar el _pipe_ (` |> `) `Ctrl+ Shift+ M`

# Loops, condicionales y funciones

## Loops

Un __loop__ es una estructura de código que nos permite aplicar iterativamente un mismo conjunto de comandos, variando el valor de una variable. 

Un loop puede iterar sobre cualquier tipo de vector, independientemente de lo que contenga.

> Los loops son una estructura básica que existe en cualquier lenguaje de programación. En R no recomendamos abusar de ellos porque hacen que el código sea más lento.

```{r,warning=FALSE}
for(i in 1:10){
   print(i^2)
}
```

Esto se lee como: "Recorre cada uno de los valores (i) del vector numérico 1 a 10, y para cada uno de ellos imprimí el cuadrado (i^2)". 

Se puede especificar la palabra que se desee que tome cada uno de los valores que debe tomar. En el ejemplo anterior fue **i**, pero bien podría ser "**Valores**".

```{r}
for(Valores in 1:10){
   print(Valores^2)
  
}
```


Al usar `print()` sólo mostrará los resultados de las operaciones en la consola, no los asignará a un objeto.

Se puede usar estos valores para asignar cada valor resultante de nuestras operaciones a una posición específica en un vector, incluso si este está vacio.

Creamos un vector vacío, asignándole como `NULL` como valor.

```{r}
mi_vector <- NULL # creamos vector vacio

for(i in 1:10) {
  mi_vector[i] <- i ^ 2
}

```


Aunque no fueron mostrados en la consola, los resultados han sido asignados al objeto `mi_vector`.

```{r}
mi_vector
```

## Estructuras Condicionales

Las __estructuras condiconales__ nos permiten ejecutar una porción de código en caso de que cumplan una condición lógica.


## if y else

Su funcionamiento es el siguiente:    

```if(condición){código a ejecutar si se cumple la condición}```

```{r,warning=FALSE}
if( 2+2 == 4){
  print("Menos Mal")
}

```

```{r,warning=FALSE}
if( 2+2 == 148.24){
  print("R, tenemos un problema")
}

```

`else` complementa un `if`, pues indica qué ocurrirá cuando la condición no se cumple, es falsa (FALSE), en lugar de no hacer nada.

**SI** esta condición es cierta, **ENTONCES** realiza estas operaciones, **DE OTRO MODO** realiza estas otras operaciones.

```{r}
# No se cumple la condición y se muestra "Falso"
if(4 > 5) {
  "Verdadero"
} else {
  "Falso"
}
```


### ifelse

La función `ifelse( )` nos permite vectorizar `if`, `else`. En lugar de escribir una línea de código para cada comparación, podemos usar una sola llamada a esta función, que se aplicará a todos los elementos de un vector. 

Su funcionamiento es el siguiente:    

```if_else(condición, función a aplicar si se cumple la condición, función a aplicar si no se cumple la condición)```

```{r}
library(dplyr)
if_else(2+2 == 4, # condicion
        true = "Joya", # si se cumple la condición
        false = "Error") # si no se cumple
```

Muy util para  recodificar datos

```{r}
num <- c(0, 1, 0, 0, 0, 1, 1)

num <- ifelse(num == 0, 
              "Hombre",
              "Mujer")

num
```

## Funciones

La creación de __funciones__ propias nos permite automatizar todas aquellas partes del código que se repiten mucho. Una vez diseñadas, funcionan igual que cualquier comando. 

Por ejemplo, podemos definir la suma de dos elementos como

```{r}
suma <- function(valor1, valor2) {
  valor1+valor2
}

suma(5,6)
```

Obviamente las funciones no son sólo para variables numéricas. Por ejemplo, podemos pegar dos strings con una flecha en el medio

```{r}
funcion_prueba <- function(parametro1,parametro2) {
  paste(parametro1, parametro2, sep = " <--> ")
}

funcion_prueba(parametro1 = "A ver", parametro2 = "Qué pasa")

```

También podemos asignar un valor por default para los parametros en caso de que el usuario no defina su valor al utilizar la función.

```{r}
Otra_funcion_prueba <- function(parametro1, parametro2 = "String default") {
  paste(parametro1, parametro2, sep = " <--> ")
  
}
Otra_funcion_prueba(parametro1 = "Valor 1")
Otra_funcion_prueba(parametro1 = "Valor 1", parametro2 = "Valor 2" )
```

Las funciones que creamos nosotros permanecen en el ambiente de R temporariamente. Cuando removemos los objetos del ambiente, la función deja de existir. Por ende, debemos incorporarla en cada uno de los scripts en la cual la necesitemos.

Una buena práctica, es incorporar nuestras funciones útiles al comienzo de cada script junto a la carga de las librerías.                         

> Vale mencionar que __lo que ocurre en una función, queda en la función__ excepto que explícitamente pidamos que devuelva el resultado, con el comando `print()`. 

Las funciones siempre devuelven el último objeto que se crea en ellas, o si explicitamente se utiliza el comando `return()`

**Funciones anónimas**

Son funciones a las cuales no les asignamos un nombre. Esto suele ser útil para hacer funciones pequeñas dentro de otras funciones o estructuras más complejas.

```{r}
(function(x) x*2)(10)
```


